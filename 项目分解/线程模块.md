# 线程模块

## 线程的基础知识

### CPU 时间片
```
时间片即CPU分配给各个程序的时间，每个线程被分配一个时间段，称作它的时间片。
即该进程允许运行的时间，使各个程序从表面上看是同时进行的。
如果在时间片结束时进程还在运行，则CPU将被剥夺并分配给另一个进程。
如果进程在时间片结束前阻塞或结束，则CPU当即进行切换。
而不会造成CPU资源浪费。
在宏观上：我们可以同时打开多个应用程序，每个程序并行不悖，同时运行。
但在微观上：由于只有一个CPU，一次只能处理程序要求的一部分，如何处理公平，一种方法就是引入时间片，每个程序轮流执行。
线程(任务)会因为CPU时间片轮转机制，而不断的切换，且无序！
```

### CPU上下文切换

```
在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行。
也就是说，需要系统事先帮它设置好 CPU 寄存器和程序计数器（Program Counter，PC）。
CPU 寄存器，是 CPU 内置的容量小、但速度极快的内存。
而程序计数器，则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。
它们都是 CPU 在运行任何任务前，必须的依赖环境，因此也被叫做 CPU 上下文。

CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，
然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。
而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。
这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行
```

- 线程是cpu执行的最小单位，包括线程ID，程序计数器，寄存器集和栈。和其他同属于一个进程的其他线程共享操作系统资源：代码区，数据区打开文件和信号。
- CPU会使用时间片轮询机制调度【任务】，其中的任务就是所谓的【线程】。

#### 线程的函数

```cpp
//创建线程开始运行相关线程函数，运行结束则线程退出
pthread_create()
//因为exit()是用来结束进程的，所以则需要使用特定结束线程的函数	
pthread_eixt()	
//挂起当前线程，用于阻塞式地等待线程结束，如果线程已结束则立即返回，0=成功
pthread_join()	
//发送终止信号给thread线程，成功返回0，但是成功并不意味着thread会终止
pthread_cancel()	
//在不包含取消点，但是又需要取消点的地方创建一个取消点，以便在一个没有包含取消点的执行代码线程中响应取消请求.
pthread_testcancel()
//设置本线程对Cancel信号的反应	
pthread_setcancelstate()
//设置取消状态 继续运行至下一个取消点再退出或者是立即执行取消动作	
pthread_setcanceltype()	
//设置取消状态
pthread_setcancel()	
```

### 互斥锁的使用方法

```cpp
#include <pthread.h>

// 声明一个互斥量    
pthread_mutex_t mtx;

// 初始化 （这里我认为 mtx 才是真正的【互斥锁】）
int pthread_mutex_init(&mtx, NULL);

// 加锁  
int pthread_mutex_lock(&mtx);

// 解锁 
int pthread_mutex_unlock(&mtx);

// 销毁
int pthread_mutex_destroy(&mtx);
```

### 条件变量

```cpp
让CPU时间片轮询机制变得可控。
因为CPU时间片轮询并不是顺序的，而是抢占式的。
条件变量的存在可以让一个任务执行完成后指定下一个要执行的任务。
这样执行顺序就能被确定下来，保证我们的逻辑正常。
```
- 条件变量的方法:
```cpp
#include <pthread.h>
#include <time.h>

// 声明一个互斥量    
pthread_mutex_t mtx;
// 申明一个条件变量
pthread_cond_t cond;

timespec abstime;
abstime.tv_sec = time(NULL) + 3;  
abstime.tv_nsec = 0;  

// 初始化条件变量
int pthread_cond_init(&cond, NULL);
 
// 阻塞等待
int pthread_cond_wait(&cond, &mtx);
 
// 超时等待
int pthread_cond_timewait(&cond, &mtx, &abstime);
 
// 解除所有线程的阻塞
int pthread_cond_destroy(&cond);
 
// 至少唤醒一个等待该条件的线程
int pthread_cond_signal(&cond);
 
// 唤醒等待该条件的所有线程
int pthread_cond_broadcast(&cond);  
```

### 信号量
```cpp
信号量是用来解决线程同步和互斥的通用工具， 和互斥量类似。 
信号量也可以用作自于资源互斥访问， 但信号量没有所有者的概念，在应用上比互斥量更广泛，信号量比较简单， 不能解决优先级反转问题。
但信号量是一种轻量级的对象，比互斥量小巧，灵活，因此在很多对互斥要求不严格的的系统中，经常使用信号量来管理互斥资源。
如果定义的信号量表示一种资源，则它是用来同步的，如果信号量定义成一把锁，则它是用来保护的。
```
- 信号量的用法
```cpp
#include <pthread.h>

// 声明一个信号量
sem_t sem;

// 初始化信号量
int sem_init(&sem, 0, 0);
 
// 信号量P操作（减 1）
int sem_wait(&sem);
 
// 以非阻塞的方式来对信号量进行减1操作
int sem_trywait(&sem);
 
// 信号量V操作（加 1）
int sem_post(&sem);
 
// 获取信号量的值
int value;
int sem_getvalue(&sem, &value);
 
// 销毁信号量
int sem_destroy(&sem);
```

### 读写锁

```cpp
#include <pthread.h>

// 定义读写锁
pthread_rwlock_t rwlock;

// 初始化
pthread_rwlock_init(&rwlock, NULL);  

// 加读锁
int pthread_rwlock_rdlock(&rwlock);

// 加写锁
int pthread_rwlock_wrlock(&rwlock);

// 释放锁
int pthread_rwlock_unlock(&rwlock);
```

### 自旋锁-spinlock
```cpp
一种基于忙等待的锁机制，它是一种轻量级的锁实现方式。
与传统的阻塞锁不同，自旋锁在获取锁时不会主动阻塞线程，而是通过循环不断地尝试获取锁，直到成功获取为止。

在多核处理器的环境下，自旋锁通常会使用底层的原子操作（如CAS）来实现。
当一个线程尝试获取自旋锁时，如果发现锁已经被其他线程持有，它会在循环中不断地检查锁的状态，而不是被挂起或阻塞。
这样做的目的是为了避免线程被切换到其他任务上，从而减少上下文切换的开销。
```

```cpp
#include <pthread.h>

// 声明一个互斥量    
pthread_spinlock_t spinlock;

// 初始化 
int pthread_spin_init(&spinlock, NULL);

// 加锁  
int pthread_spin_lock(&spinlock);

// 加锁，申请不到直接返回；
int pthread_spin_trylock(&spinlock);

// 解锁 
int pthread_spin_unlock(&spinlock);

// 销毁
int pthread_spin_destroy(&spinlock);
```

## Thread类的封装

```cpp
class Thread {
public:
    typedef std::shared_ptr<Thread> ptr;
    Thread(std::function<void()> cb, const std::string& name);
    ~Thread();

    pid_t getId() const { return m_id;}
    const std::string& getName() const { return m_name;}

    void join();

    static Thread* GetThis();
    static const std::string& GetName();
    static void SetName(const std::string& name);
private:
    Thread(const Thread&) = delete;
    Thread(const Thread&&) = delete;
    Thread& operator=(const Thread&) = delete;

    static void* run(void* arg);
private:
    pid_t m_id = -1;
    pthread_t m_thread = 0;
    std::function<void()> m_cb;
    std::string m_name;
    //用于保证线程创建成功之后再执行对应方法
    Semaphore m_semaphore;
};

// 这个表示线程的局部存储，每个线程都有一个自己的t_thread指针
static thread_local Thread* t_thread = nullptr;
static thread_local std::string t_thread_name = "UNKNOW";
```

- 为每个线程创建了一个局部存储的变量t_thread，用于存储当前线程的Thread对象指针。

- 线程真正的运行函数是run函数，它会调用传入的回调函数m_cb。
```cpp
void* Thread::run(void* arg) {
  Thread* thread = (Thread*)arg;
  t_thread = thread;
  t_thread_name = thread->m_name;
  // 设置当前线程的id
  // 只有进了run方法才是新线程在执行，创建时是由主线程完成的，threadId为主线程的
  thread->m_id = sylar::GetThreadId();
  pthread_setname_np(pthread_self(), thread->m_name.substr(0, 15).c_str());
  std::function<void()> cb;
  cb.swap(thread->m_cb);
  thread->m_semaphore.notify();
  cb();
  return 0;
}
```
- 其中先将当前线程的t_thread指针指向当前线程的Thread对象，然后调用pthread_setname_np函数设置当前线程的名称，最后调用传入的回调函数m_cb。

-然后利用swap进行替换，将t_thread中的m_cb替换出来给cb，然后对应执行cb()

## Semaphore类的封装
```cpp
class Semaphore : Noncopyable {
 public:
  Semaphore(uint32_t count = 0);
  ~Semaphore();
  void wait();
  void notify();

 private:
  sem_t m_semaphore;
};
```
- 对其进行了不能拷贝的限制
- 封装了信号量的创建，销毁，等待，通知等方法

### 后续一些锁的封装部分













