## 配置系统


### ConfigVarBase : 基础信息对象
- 配置项的基类，定义了配置项的公共成员和方法。它是一个虚基类，对每个配置项都包括名称和描述两项成员、以及toString和fromString纯虚函数方法。它并不包含配置项的类型和值，而是由继承类实现。
```cpp
class ConfigVarBase {
 public:
  typedef std::shared_ptr<ConfigVarBase> ptr;
  ConfigVarBase(const std::string& name, const std::string& description = "")
      : m_name_(name), m_description(description) {
    //将名称变成大小写不敏感的
    std::transform(m_name_.begin(), m_name_.end(), m_name_.begin(), ::tolower);
  }
  //有具体类型的子类，所以需要变成 虚析构函数
  virtual ~ConfigVarBase() {}
  const std::string& getName() const { return m_name_; }
  const std::string& getDescription() const { return m_description; }
  virtual std::string toString() = 0;
  virtual bool fromString(const std::string& str) = 0;
  virtual std::string getTypeName() const = 0;

 protected:
  std::string m_name_;
  std::string m_description;
};
```

### ConfigVar : 不同类型的配置变量，就是基于ConfigVarBase的子类
- ConfigVar：具体的配置参数类，继承自ConfigVarBase，是一个模板类，具有三个模板参数。第一个模板参数是配置项的类型T，第二个和第三个模板参数FromStr和ToStr是仿函数，用于类型T和YAML字符串之间的相互转换。这两个模板参数有默认值，根据不同的类型T有不同的偏特化实现。ConfigVar类包含了一个T类型的成员和一个变更回调函数数组。提供了setValue和getValue方法用于获取和更新配置值，并提供了addListener和delListener方法用于添加或删除配置变更的回调函数。

-  成员变量：
   - typedef std::function<void(const T& old_value, const T& new_value)> on_change_cb;  
   - T m_val;
   - std::map<uint64_t, on_change_cb> m_cbs; // 回调函数的map集合
-  成员函数：
   - ConfigVar(const std::string& name, const T& default_value,
            const std::string& description = "") //构造函数
   - std::string toString() 将T成员变量转变成为数组类型
   - bool fromString(const std::string& str) override  将字符串转变成为T类型 这个里面需要考虑到从字符串给原来的m_val赋值的时候是否当前的str的值和m_val的值是否相等
      - 如果不相等的话，需要调用回调函数
   -  setValue(const T& v) 重新设置m_val的值,里面就是实行回调的逻辑
   - std::string getTypeName() 获取T类型名字
   - uint64_t addListener(on_change_cb cb) 添加回调函数
   - void delListener(uint64_t key) 删除回调函数
   - on_change_cb getListener(uint64_t key) 获取回调函数
   - void clearListeners() 清空回调函数
  

```cpp
//FromStr T operator()(const std::string& str) const;
//ToStr std::string operator()(const T& val) const;

template <class T, class FromStr = LexicalCast<std::string, T>,
          class ToStr = LexicalCast<T, std::string>>
class ConfigVar : public ConfigVarBase {
 public:
  typedef RWMutex RWMutexType;
  typedef std::shared_ptr<ConfigVar> ptr;
  typedef std::function<void(const T& old_value, const T& new_value)>
      on_change_cb;  //回调函数

  ConfigVar(const std::string& name, const T& default_value,
            const std::string& description = "")
      : ConfigVarBase(name, description), m_val(default_value) {}
  std::string toString() override {
    try {
      //return  boost::lexical_cast<std::string>(m_val);
      RWMutexType::ReadLock lock(m_mutex);
      return ToStr()(m_val);
    } catch (std::exception& e) {
      SYLAR_LOG_ERROR(SYLAR_LOG_ROOT())
          << "configVar::toString exception" << e.what()
          << "convert :" << typeid(m_val).name() << " to string";
    }
    return "";
  }
  bool fromString(const std::string& str) override {
    try {
      //m_val = boost::lexical_cast<T>(str);
      setValue(FromStr()(str));
    } catch (std::exception& e) {
      SYLAR_LOG_ERROR(SYLAR_LOG_ROOT())
          << "configVar::toString exception" << e.what()
          << "convert: string to " << typeid(m_val).name() << " - " << str;
    }
    return false;
  }

  const T getValue() const {
    RWMutexType::ReadLock lock(m_mutex);
    return m_val;
  }

  void setValue(const T& v) {
    {
      RWMutexType::ReadLock lock(m_mutex);
      if (v == m_val) {
        return;
      }
      for (auto& cb : m_cbs) {
        cb.second(m_val, v);
      }
    }
    RWMutexType::WriteLock lock(m_mutex);
    m_val = v;
  }

  std::string getTypeName() const { return typeid(T).name(); }

  uint64_t addListener(on_change_cb cb) {
    static uint64_t s_func_id = 0;
    RWMutexType::WriteLock lock(m_mutex);
    ++s_func_id;
    m_cbs[s_func_id] = cb;
    return s_func_id;
  }

  void delListener(uint64_t key) {
    RWMutexType::WriteLock lock(m_mutex);
    m_cbs.erase(key);
  }

  on_change_cb getListener(uint64_t key) {
    RWMutexType::ReadLock lock(m_mutex);
    auto it = m_cbs.find(key);
    return it == m_cbs.end() ? nullptr : it->second;
  }

  void clearListeners() {
    RWMutexType::WriteLock lock(m_mutex);
    m_cbs.clear();
  }

 private:
  mutable RWMutexType m_mutex;
  T m_val;
  //变更回调函数数组，uint64_t key要求唯一，一般可以使用hash
  std::map<uint64_t, on_change_cb> m_cbs;
};
```

### LexicalCast : 类型转换
- 1. //F from_type, T to_type:template <class F, class T>，F是源类型，T是目标类型
- 2. //string, std::vector<T> : template <class T> class LexicalCast<std::string, std::vector<T>>
- 3. //std::vector<T>, string : template <class T> class LexicalCast<std::vector<T>, std::string>
- 4. // std::list<T>, std::string: template <class T> class LexicalCast<std::list<T>, std::string>
- 5. //  std::string, std::set<T>: template <class T>class LexicalCast<std::string, std::set<T>>
- 6. //  std::string, std::set<T>: template <class T> class LexicalCast<std::string, std::set<T>>
- 7. //  std::set<T>, std::string : template <class T> class LexicalCast<std::set<T>, std::string>
- 8. //  std::string, std::unordered_set<T> : template <class T>class LexicalCast<std::string, std::unordered_set<T>>
- 9. // std::unordered_set<T>, std::string : template <class T> class LexicalCast<std::unordered_set<T>, std::string>
- 10. // std::string, std::map<std::string, T> : template <class T> class LexicalCast<std::string, std::map<std::string, T>>
- 11. // std::map<std::string, T>, std::string : template <class T> class LexicalCast<std::map<std::string, T>, std::string>
- 12. // std::string, std::unordered_map<std::string, T> : template <class T> class LexicalCast<std::string, std::unordered_map<std::string, T>>
- 13. // std::unordered_map<std::string, T>, std::string : template <class T> class LexicalCast<std::unordered_map<std::string, T>, std::string>



### Config : 处理yaml的配置文件的解析
- ConfigVar的管理类，负责管理所有的ConfigVar对象，采用单例模式。提供了Lookup方法，用于根据配置名称查询配置项。如果提供了默认值和描述信息，那么在未找到对应的配置项时，会自动创建一个对应的配置项。此外，Config类还提供了LoadFromYaml和LoadFromConfDir方法，用于从YAML对象或命令行选项指定的配置文件路径中加载配置。Config类的所有成员变量和方法都是静态的，保证了全局只有一个实例。
```cpp
class Config {
 public:
  typedef std::unordered_map<std::string, ConfigVarBase::ptr> ConfigVarMap;
  typedef RWMutex RWMutexType;
  static typename ConfigVar<T>::ptr Lookup(
      const std::string& name, const T& default_value,
      const std::string& description = "");

  template <class T>
  static typename ConfigVar<T>::ptr Lookup(const std::string& name);

  static void LoadFromYaml(const YAML::Node& root);

  static ConfigVarBase::ptr LookupBase(const std::string& name);

  static void Visit(std::function<void(ConfigVarBase::ptr)> cb);

private:
  static ConfigVarMap& GetDatas() {
    static ConfigVarMap m_datas;
    return m_datas;
  }
  static RWMutexType& GetMutex() {
    static RWMutexType s_mutex;
    return s_mutex;
  }
};
```
- 成员变量：
  - static ConfigVarMap& GetDatas()  静态函数，返回静态变量m_datas
  - static RWMutexType& GetMutex()  静态函数，返回静态变量s_mutex
- 成员函数：
  - static void LoadFromYaml(const YAML::Node& root); // 加载yaml配置文件
  - template <class T> static typename ConfigVar<T>::ptr Lookup(
      const std::string& name, const T& default_value,
      const std::string& description = "") // 查找配置项，如果没有找到，则创建一个
  - static typename ConfigVar<T>::ptr Lookup(const std::string& name) // 查找配置项，但是这个不会创建了
  - static void LoadFromYaml(const YAML::Node& root) // LoadFromYaml函数首先调用ListAllMember函数，将YAML节点中的所有配置项提取出来，然后遍历所有的配置项，查找对应的配置参数，如果找到，则调用fromString函数初始化配置参数的值。
  - static ConfigVarBase::ptr LookupBase(const std::string& name) //查找配置参数, 若找到参数名为name的配置参数，则返回对应的配置参数的基类（注意和上面函数的不同），否则返回nullptr。
  - static void Visit(std::function<void(ConfigVarBase::ptr)> cb) //遍历所有的配置参数，调用回调函数

### 额外的参数部分
- static void ListAllMember(
    const std::string& prefix, const YAML::Node& node,
    std::list<std::pair<std::string, const YAML::Node>>& output): 将YAML节点中的所有配置项提取出来，然后遍历所有的配置项，查找对应的配置参数，如果找到，则调用fromString函数初始化配置参数的值。


## 将配置系统与日志模块相互结合
```cpp
- log.yaml配置文件
logs:
    - name: root
      level: info
      appenders:
          - type: StdoutLogAppender
            pattern: "%d{%Y-%m-%d %H:%M:%S} %T%t%T%N%T%F%T[%p]%T[%c]%T%f:%l%T%m%n"
    - name: system
      level: info
      appenders:
          - type: StdoutLogAppender
          - type: FileLogAppender
            file: ./system.txt
- LogAppender结构体重载== 
struct LogAppenderDefine {
  int type = 0;  //1 File, 2 Stdout
  LogLevel::Level m_level = LogLevel::UNKNOW;
  std::string formatter;
  std::string file;

  bool operator==(const LogAppenderDefine& oth) const {
    return type == oth.type && m_level == oth.m_level &&
           formatter == oth.formatter && file == oth.file;
  }
};
- LogDefine结构体重载==、<
struct LogDefine {
    std::string name;
    LogLevel::Level level = LogLevel::NOTSET;
    std::vector<LogAppenderDefine> appenders;

    bool operator==(const LogDefine& oth) const {
        return name == oth.name && level == oth.level && appenders == oth.appenders;
    }

    bool operator<(const LogDefine& oth) const {
        return name < oth.name;
    }

    bool isValid() const {
        return !name.empty();
    }
};
- 将YAML格式的字符串反序列化为一个LogDefine对象
template <>
class LexicalCast<std::string, std::set<LogDefine>> {
 public:
  std::set<LogDefine> operator()(const std::string& v) {
    YAML::Node node = YAML::Load(v);
    std::set<LogDefine> vec;
    for (size_t i = 0; i < node.size(); ++i) {
      auto n = node[i];
      if (!n["name"].IsDefined()) {
        std::cout << "log config error: name is null," << n << std::endl;
        continue;
      }
      LogDefine ld;
      ld.name = n["name"].as<std::string>();
      ld.m_level = LogLevel::FromString(
          n["level"].IsDefined() ? n["level"].as<std::string>() : "");
      if (n["formatter"].IsDefined()) {
        ld.formatter = n["formatter"].as<std::string>();
      }
      if (n["appenders"].IsDefined()) {
        for (size_t x = 0; x < n["appenders"].size(); ++x) {
          auto a = n["appenders"][x];
          if (!a["type"].IsDefined()) {
            std::cout << "log config error: appender type is null," << a
                      << std::endl;
            continue;
          }
          std::string type = a["type"].as<std::string>();
          LogAppenderDefine lad;
          if (type == "FileLogAppender") {
            lad.type = 1;
            if (!a["file"].IsDefined()) {
              std::cout << "log config error: fileappender is null," << a
                        << std::endl;
              continue;
            }
            lad.file = a["file"].as<std::string>();
            if (a["formatter"].IsDefined()) {
              lad.formatter = a["formatter"].as<std::string>();
            }
          } else if (type == "StdoutLogAppender") {
            lad.type = 2;
          } else {
            std::cout << "log config error: name is invalid," << a << std::endl;
            continue;
          }
          ld.appenders.push_back(lad);
        }
      }
      //          std::cout << "----" << ld.name << "-"
      //                    << ld.appenders.size() << std::endl;
      vec.insert(ld);
    }
    return vec;
  }
};
- 将std::set<LogDefine> 转变成为string
template <>
class LexicalCast<std::set<LogDefine>, std::string> {
 public:
  std::string operator()(const std::set<LogDefine>& v) {
    YAML::Node node;
    for (auto& i : v) {
      YAML::Node n;
      n["name"] = i.name;
      if (i.m_level != LogLevel::UNKNOW) {
        n["level"] = LogLevel::ToString(i.m_level);
      }
      if (i.formatter.empty()) {
        n["formatter"] = i.formatter;
      }
      for (auto& a : i.appenders) {
        YAML::Node na;
        if (a.type == 1) {
          na["type"] = "FileLogAppender";
          na["file"] = a.file;
        } else if (a.type == 2) {
          na["type"] = "StdoutLogAppender";
        }
        if (a.m_level != LogLevel::UNKNOW) {
          na["level"] = LogLevel::ToString(a.m_level);
        }
        if (!a.formatter.empty()) {
          na["formatter"] = a.formatter;
        }

        n["appenders"].push_back(na);
      }
      node.push_back(n);
    }
    std::stringstream ss;
    ss << node;
    return ss.str();
  }
};
```

#### 自动初始化logInter ：使用YAML配置文件初始化日志系统，并确保当日志配置发生变化时，系统能够相应地更新日志设置

```cpp
- 
sylar::ConfigVar<std::set<LogDefine>>::ptr g_log_defines =
    sylar::Config::Lookup("logs", std::set<LogDefine>(), "log config");

struct LogIniter {
  LogIniter() {
    g_log_defines->addListener([](const std::set<LogDefine>& old_value,
                                  const std::set<LogDefine>& new_value) {
      SYLAR_LOG_INFO(SYLAR_LOG_ROOT()) << "on_logger_conf_changed";
      //新增
      for (auto& i : new_value) {
        auto it = old_value.find(i);
        sylar::Logger::ptr logger;
        if (it == old_value.end()) {
          //新增logger
          logger = SYLAR_LOG_NEAME(i.name);
        } else {
          if (!(i == *it)) {
            //修改的logger
            logger = SYLAR_LOG_NEAME(i.name);
          }
        }
        logger->setLevel(i.m_level);
        if (!i.formatter.empty()) {
          logger->setFormatter(i.formatter);
        }
        logger->clearAppenders();
        for (auto& a : i.appenders) {
          sylar::LogAppender::ptr ap;
          if (a.type == 1) {
            ap.reset(new FileLogAppender(a.file));
          } else if (a.type == 2) {
            ap.reset(new StdoutLogAppender);
          }
          ap->setLevel(a.m_level);
          if (!a.formatter.empty()) {
            LogFormatter::ptr fmt(new LogFormatter(a.formatter));
            if (!fmt->isError()) {
              ap->setFormatter(fmt);
            } else {
              std::cout << "appender name =" << i.name
                        << "appender type=" << a.type
                        << "formatter=" << a.formatter << "is invalid"
                        << std::endl;
            }
          }
          logger->addAppender(ap);
        }
      }
      for (auto& i : old_value) {
        auto it = new_value.find(i);
        if (it == new_value.end()) {
          //删除logger
          auto logger = SYLAR_LOG_NEAME(i.name);
          logger->setLevel((LogLevel::Level)100);
          logger->clearAppenders();
        }
      }
    });
  }
};
```

