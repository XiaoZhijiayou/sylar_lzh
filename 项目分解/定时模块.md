## 定时器模块
- 本项⽬的定时器是为了实现协程调度器对定时任务的调度，服务器上经常要处理定时事件，比如3秒后关闭一个连接，或者是定期检查一个客户端的连接状态，定时器也是后面hook模块的基础
##### linux提供的定时机制，目前linux提供了以下几种可供程序利用的定时机制：
  - 1. alarm()或setitimer()，这俩的本质都是先设置⼀个超时时间，然后等SIGALARM信号触发，通过捕获信号来判断超时
  - 2. 套接字超时选项，对应SO_RECVTIMEO和SO_SNDTIMEO，通过errno来判断超时
  - 3. 多路复⽤超时参数，select/poll/epoll都支持设置超时参数，通过判断返回值为0来判断超时
  - 4. timer_create系统接⼝，实质也是借助信号，参考man 2 timer_create
  - 5. timerfd_create系列接⼝，通过判断⽂件描述符可读来判断超时，可配合IO多路复⽤，参考man 2 timerfd_create
- 服务器程序通常需要处理众多定时事件，如何有效地组织与管理这些定时事件对服务器的性能至关重要。为此，我们要将每个定时事件分别封装成定时器，并使用某种容器类数据结构，比如链表、排序链表和时间轮，将所有定时器串联起来，以实现对定时事件的统一管理，每个定时器通常至少包含两个成员：一个超时时间（相对时间或绝对时间）和一个任务回调函数。除此外，定时器还可以包括回调函数参数及是否自动重启等信息。
- 有两种高效管理定时器的容器：时间轮和时间堆，sylar使用时间堆的方式管理定时器。

###### 1.基于升序链表的定时器
  - 1. 所有定时器组织成链表结构，链表成员包含超时时间，回调函数，回调函数参数，以及链表指针域。
  - 2. 定时器在链表中按超时时间进行升序排列，超时时间短的在前，长的在后。每次添加定时器时，都要按超时时间将定时器插入到链表的指定位置。
  - 3. 程序运行后维护一个周期性触发的tick信号，比如利用alarm函数周期性触发ALARM信号，在信号处理函数中从头遍历定时器链表，判断定时器是否超时。如果定时器超时，则记录下该定时器，然后将其从链表中删除。
  - 4. 执行所有超时的定时器的回调函数。
- 以上就是一个基于升序链表的定时器实现，这种方式添加定时器的时间复杂度是O(n)，删除定时器的时间复杂度是O(1)，执行定时任务的时间复杂度是O(1)。tick信号的周期对定时器的性能有较大的影响。当tick信号周期较小时，定时器精度高，但CPU负担较高，因为要频繁执行信号处理函数；当tick信号周期较大时，CPU负担小，但定时精度差。当定时器数量较多时，链表插入操作开销

###### 2.[时间轮]<https://blog.csdn.net/dddgggd/article/details/129211160>
- 与上面的升序链表实现方式类似，也需要维护一个周期性触发的tick信号，但不同的是，定时器不再组织成单链表结构，而是按照超时时间，通过散列分布到不同的时间轮上，像下面这样：
  - ![alt text](image-9.png)
- 上面的时间轮包含N个槽位，每个槽位上都有一个定时器链表。时间轮以恒定的速度顺时针转动，每转一步，表盘上的指针就指向下一个槽位。每次转动对应一个tick，它的周期为si，一个共有N个槽，所以它运转一周的时间是N*si。每个槽位都有一条定时器链表，同一条链表上的每个定时器都具有相同的特征：前后节点的定时时间相差N*si的整数倍。时间轮正是利用这个关系将定时器散列到不同的链表上。假如现在指针指向槽cs，我们要添加一个定时时间为ti的定时器，则该定时器将被插入槽ts(time slot)对应的链表中：ts = (cs + (ti / si)) % N。
-  时间轮通过哈希表的思想，将定时器散列到不同的链表上，每个链表的定时器数目都明显少于原来的排序链表，插入效率基本不受定时器数目的影响。和升序链表一样，tick的周期将影响定时器精度和CPU负载，除此外，时间轮上的槽数量N还对定时器的效率有影响，N越大，则散列越均匀，插入效率越高，N越小，则散列越容易冲突，至N等于1时，时间轮将完全退化成升序链表。
-  上面的时间轮只有一个轮子，而复杂的时间轮可能有多个轮子，不同的轮子拥有不同的粒度。相邻的两个轮子，精度高的转一圈，精度低的仅往前移动一槽，就像水表一样。

  单个槽上的定时器链表仍然是按升序链表来组织的，只不过前后两个节点的时间差一定是N*si的整数倍。注意这里前后节点的时间差不一定是1个N*si，也有可能是好几个N*si，所以不能通过定时器所在的槽位和链表位置直接推算出定时器的超时时间。或者换个说法，表盘指针转到某个槽时，仍需要按升序链表的方式遍历这个链表的节点，并判断是否超时。

###### 时间堆
- 上面的两种定时器设计都依赖一个固定周期触发的tick。设计定时器的另一种实现思路是直接将超时时间当作tick周期，具体操作是每次都取出所有定时器中超时时间最小的超时值作为一个tick，这样，一旦tick触发，超时时间最小的定时器必然到期。处理完已超时的定时器后，再从剩余的定时器中找出超时时间最小的一个，并将这个最小时间作为下一个tick，如此反复，就可以实现较为精确的定时。最小堆很适合处理这种定时方案，将所有定时器按最小堆来组织，可以很方便地获取到当前的最小超时时间，sylar采取的即是这种方案。

### 2. 定时器的设计
- 本文的定时器设计： sylar的定时器采用最小堆设计，所有定时器根据绝对的超时时间点进行排序，每次取出离当前时间最近的一个超时时间点，计算出超时需要等待的时间，然后等待超时。超时时间到后，获取当前的绝对时间点，然后把最小堆里超时时间点小于这个时间点的定时器都收集起来，执行它们的回调函数。

  - 注意，在注册定时事件时，一般提供的是相对时间，比如相对当前时间3秒后执行。sylar会根据传入的相对时间和当前的绝对时间计算出定时器超时时的绝对时间点，然后根据这个绝对时间点对定时器进行最小堆排序。因为依赖的是系统绝对时间，所以需要考虑校时因素，这点会在后面讨论。
- sylar定时器的超时等待基于epoll_wait，精度只支持毫秒级，因为epoll_wait的超时精度也只有毫秒级。关于定时器和IO协程调度器的整合。IO协程调度器的idle协程会在调度器空闲时阻塞在epoll_wait上，等待IO事件发生。在之前的代码里，epoll_wait具有固定的超时时间，这个值是5秒钟。加入定时器功能后，epoll_wait的超时时间改用当前定时器的最小超时时间来代替。epoll_wait返回后，根据当前的绝对时间把已超时的所有定时器收集起来，执行它们的回调函数。由于epoll_wait的返回并不一定是超时引起的，也有可能是IO事件唤醒的，所以在epoll_wait返回后不能想当然地假设定时器已经超时了，而是要再判断一下定时器有没有超时，这时绝对时间的好处就体现出来了，通过比较当前的绝对时间和定时器的绝对超时时间，就可以确定一个定时器到底有没有超时。

#### 2.1 Timer类
- 成员变量：
```cpp
bool m_recurring = false;           // 是否循环定时器
uint64_t    m_ms = 0;               // 执行周期
uint64_t  m_next = 0;               // 精确的执行时间
std::function<void()> m_cb;         // 定时器回调函数
TimerManager* m_manager = nullptr;  // 定时器管理器指针
```

#### 2.2 Comparator类
```cpp
// 定时器比较仿函数
struct Comparator {
    /**
        * @brief 重载()操作符，用于定时器的比较、排序
        * @details 比较两个定时器的执行时间，按照执行时间从小到大排序，如果执行时间相同，地址小的排在前面
        * @param[in] lhs 定时器指针_left hand side
        * @param[in] rhs 定时器指针_right hand side
    */
    bool operator()(const Timer::ptr& lhs, const Timer::ptr& rhs) const;
};
```

#### 2.3 TimerManager类
- 所有的Timer对象都由TimerManager类进行管理，TimerManager包含一个std::set类型的Timer集合，这个集合就是定时器的最小堆结构，因为set里的元素总是排序过的，所以总是可以很方便地获取到当前的最小定时器。TimerManager提供创建定时器，获取最近一个定时器的超时时间，以及获取全部已经超时的定时器回调函数的方法，并且提供了一个onTimerInsertedAtFront()方法，这是一个虚函数，由IOManager继承时实现，当新的定时器插入到Timer集合的首部时，TimerManager通过该方法来通知IOManager立刻更新当前的epoll_wait超时。TimerManager还负责检测是否发生了校时，由detectClockRollover方法实现。
- 成员变量：

```cpp
RWMutexType m_mutex;       
std::set<Timer::ptr, Timer::Comparator> m_timers;   // 定时器集合
bool m_tickled = false;         // 是否触发onTimerInsertedAtFront
uint64_t m_previousTime = 0;    // 上次执行时间
```

